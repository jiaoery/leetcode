# Leetcode刷题记录
leetcode题库网址：[https://leetcode-cn.com/](https://leetcode-cn.com/)
## Question1:两数之和
* 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。

>示例:
>给定 nums = [2, 7, 11, 15], target = 9
>因为 nums[0] + nums[1] = 2 + 7 = 9
>所以返回 [0, 1]

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode1)

## Question2:两数相加
* 给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例：

>输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
>输出：7 -> 0 -> 8
>原因：342 + 465 = 807

使用到的数据结构:链表结构
```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
```
 解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode02)



# Questtion3:寻找数组的中心索引

* 给定一个整数类型的数组 `nums`，请编写一个能够返回数组 **“中心索引”** 的方法。

  我们是这样定义数组 **中心索引** 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

  如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

  **示例 1：**

  ```
  输入：
  nums = [1, 7, 3, 6, 5, 6]
  输出：3
  解释：
  索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。
  同时, 3 也是第一个符合要求的中心索引。
  ```

  **示例 2：**

  ```
  输入：
  nums = [1, 2, 3]
  输出：-1
  解释：
  数组中不存在满足此条件的中心索引。
  ```

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode03)

# Question4：搜索插入位置

* 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
* 你可以假设数组中无重复元素。

**示例 1:**

```
输入: [1,3,5,6], 5
输出: 2
```

**示例 2:**

```
输入: [1,3,5,6], 2
输出: 1
```

**示例 3:**

```
输入: [1,3,5,6], 7
输出: 4
```

**示例 4:**

```
输入: [1,3,5,6], 0
输出: 0
```

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode04)

# Question5：打乱数组

* 打乱一个没有重复元素的数组。 

**示例:**

```java
// 以数字集合 1, 2 和 3 初始化数组。
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。
solution.shuffle();

// 重设数组到它的初始状态[1,2,3]。
solution.reset();

// 随机返回数组[1,2,3]打乱后的结果。
solution.shuffle();


```

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode05)

# Question6:旋转数组

* 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例 1:**

```
输入: [1,2,3,4,5,6,7] 和 k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

**示例 2:**

```
输入: [-1,-100,3,99] 和 k = 2
输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```


**说明:**

* 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
* 要求使用空间复杂度为 O(1) 的 原地 算法。

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode06)

# Question7:除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

* 选出任一 x，满足 0 < x < N 且 N % x == 0 。
* 用 N - x 替换黑板上的数字 N 。
* 如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

 

**示例 1：**

> 输入：2
> 输出：true
> 解释：爱丽丝选择 1，鲍勃无法进行操作。

**示例 2：**

> 输入：3
> 输出：false
> 解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。

**提示：**

> 1 <= N <= 1000

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode07)

## Question8:二叉树最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:**叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 [3,9,20,null,null,15,7]，

     3
    / \
    9  20
      /  \
     15   7

返回它的最大深度 3 。

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode08)

## Question9:整数反转

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

> 输入: 123
> 输出: 321

**示例 2:**

> 输入: -123
> 输出: -321

**示例 3:**

> 输入: 120
> 输出: 21

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode09)

## Question10：魔术索引

魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

**示例1:**

> 输入：nums = [0, 2, 3, 4, 5]
>  输出：0
>  说明: 0下标的元素为0

**示例2:**

>  输入：nums = [1, 1, 1]
>  输出：1

**说明:**

​	此题为原书中的 Follow-up，即数组中可能包含重复元素的版本

**提示:**

​	nums长度在[1, 1000000]之间

解：[点击查看答案](https://github.com/jiaoery/leetcode/tree/master/src/leetcode10)