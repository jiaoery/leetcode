# 解题思路：

该题的解题重点不在于编写代码，而是找出规律和证明规律。这个可以在很多游戏设计中经典的思路，这里的解题思路有两种：

## 1.推导法

博弈类的问题常常让我们摸不着头脑。当我们没有解题思路的时候，不妨试着写几项试试：

* 当N=1时,取值区间为(0,1)(`ps:区间概念不明白的，去看看数学教材`),此时中间无可用的N的因数，因此此时Alice败，返回false
* 当N=2时，取值区间为(0,2)，此时中间可选的只有1，Alice选1，此时Bob面临N=1的情况，故此时Bob败，Alice胜，返回tue
* 当N=3时，取值区间为(0,3),此时中间可选的只有1，Alice选择1，此时Bob面临N=2的情况，故此时Alice败，Bob胜，返回false
* 当N=4时，取值区间为(0,4),此时Alice可选择1或者2；当Alice选择1的时候，问题会变成N=3的情况，Bob败，Alice胜利，返回true;当Alice选择2的时候，问题变成N=2的情况，这时Bob胜，Alice败，返回false。从条件而言，选择最优结果。所以这里Alice选择1，Alice赢，返回true。
* *N*=5 的时候，Alice 只能拿 1，根据 N = 4*N*=4 的结论，Alice 会失败。
* ......

到这里，会发现一个规律，**就是N为奇数的时候，先手必败，N为偶数的时候先手必胜**

但是规律是无法代表结论的，从数学角度而言，我们需要严格证明。那么就用数学常用的推导法来证明：

**证明**

* 1.N=1和N=2时结论成立。（前面已经推导出的结果）

* 2.N>2时，假设N<=k时候改结论成立，则N=k+1;
  * 如果k是偶数，那么k+1为奇数。x为k+1的因数（可整除对象的数），只可能是奇数。那么奇数减去奇数结果为偶数。k+1-x<=k.故而轮到Bob的时候，必为偶数，切根据前提假设N<=k时，先手必胜利，那么Bob胜，Alice败。
  * 如果k为奇数，k+1为偶数，x可以是奇数也可以是偶数。若减去一个奇数x,k+1-x<=k，并且为偶数.此时先手必败，那么Bob败，Alice胜。

所以，综上所述，这个想法是正确的。

### 1.1 代码演示



```
public boolean divisorGame(int N) {
//处理超域
		 if(N<0||N>1000){
	            throw new RuntimeException("nums out of limit");
	        }
	        return N % 2 == 0;
	    }
```

## 1.2 复杂度分析

- 时间复杂度：`O(1)`。
- 空间复杂度：`O(1)`

## 2.动态规划算法

从方法1里面我们可以发现一个规律，就是N的问题可以变成k(k<N)的问题，极限情况下，可以回归成N=1或者N=2的问题，那么常用的算法工具：**动态规划**就可以派出用场了。

### 1.1 代码

```
public boolean divisorGame(int N) {
		 boolean[] f = new boolean[N + 5];

	        f[1] = false;
	        f[2] = true;
	        for (int i = 3; i <= N; ++i) {
	            for (int j = 1; j < i; ++j) {
	                if ((i % j) == 0 && !f[i - j]) {
	                    f[i] = true;
	                    break;
	                }
	            }
	        }

	        return f[N];
	}

```

### 1.2 复杂度

* 时间复杂度：`O(n^2）`.递推的时候一共有 n*n 个状态要计算，每个状态需要 O(n) 的时间枚举因数，因此总时间复杂度为 `O(n^2)`。
* 空间复杂度：`O(n)`。我们需要 `O(n)` 的空间存储递推数组 f的值。

