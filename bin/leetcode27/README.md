# 解体思路

## 1.1 暴力法

这个第一映像就是用暴力法，直接求解区间[m,n]的按位与，返回结果。然而悲剧的是在数量很大的情况下，会超时。

## 1.2 代码

```
public int rangeBitwiseAnd(int m, int n) {
		int shift = 0;
		while (m < n) {
			m >>= 1;
			n >>= 1;
			shift++;
		}
		return m<<shift;
	}
```

## 1.3 复杂度分析

* 时间复杂度：`O(n-m)`,循环`n-m`次
* 空间复杂度：`O(1)`,未引入其他数据结构

## 2.1 位运算

既然暴力法解决这个问题，那么是否可以换一种思路呢？

我们观察按位与运算的性质。对于一系列的位，例如 [1, 1, 0, 1, 1][1,1,0,1,1]，只要有一个零值的位，那么这一系列位的按位与运算结果都将为零。

回到本题，首先我们可以对范围内的每个数字用二进制的字符串表示，例如 9=00001001（2进制）然后我们将每个二进制字符串的位置对齐。

![fig1](https://assets.leetcode-cn.com/solution-static/201/1.png)

在上图的例子中，我们可以发现，对所有数字执行按位与运算的结果是所有对应二进制字符串的公共前缀再用零补上后面的剩余位。

那么这个规律是否正确呢？我们可以进行简单的证明。假设对于所有这些二进制串，前 `i`位均相同，第` i+1` 位开始不同，由于 `[m,n] `连续，所以第 `i+1` 位在 `[m,n] `的数字范围从小到大列举出来一定是前面全部是 `0`，后面全部是`1`，在上图中对应 `[9,11]` 均为 `0`，`[12,12] `均为 `1`。并且一定存在连续的两个数`x `和 `x+1`，满足 `x `的第 `i+1 `位为 `0`，后面全为 `1`，`x+1` 的第`i+1` 位为 `1`，后面全为 `0`，对应上图中的例子即为 `11` 和 `12`。这种形如 `0111… `和 `1000… `的二进制串的按位与的结果一定为 `0000…`，因此第`i+1` 位开始的剩余位均为 `0`，前 `i` 位由于均相同，因此按位与结果不变。最后的答案即为二进制字符串的公共前缀再用零补上后面的剩余位。

因此，最终我们可以将问题重新表述为：给定两个整数，我们要找到它们对应的二进制字符串的公共前缀。

![fig2](https://assets.leetcode-cn.com/solution-static/201/2.png)

## 2.2 代码

```
public int rangeBitwiseAnd(int m, int n) {
		int shift = 0;
		while (m < n) {
			m >>= 1;
			n >>= 1;
			shift++;
		}
		return m<<shift;
	}
```

## 2.3 复杂度分析

* 时间复杂度：`O(logn)`.算法的时间复杂度取决于`m`和`n`的二进制位数，由于`m<=n`,所以时间复杂度由n的二进制位数决定
* 空间复杂度：`O(1)`。这里只需要常数空间存放若干变量。

