# 解题思路

## 1.1 暴力法

本身这道题给出的条件是：一个数组可以修改其中一个元素的值，让其成为一个非递减数列。

那么符合最多一次修改达到效果的数列有几种情况：

* 1.本身就是非递减数列，比如：  `1,2,3`
* 2.需要修改的值在整个数组的最左边；比如：`4,2,3`
* 3.需要修改的值，不在数组的最左边，比如：`1,4,2,3`,`2,3,3,2,4`

通过分析，可以得出规律-----判断修改的数字跟前后的数字有关系；比如情况2中4>2;情况3中3>2;

但是，这里修改有两种情况分析，情况2中；需要将最左边的数字修改为第二个数字；情况2中需要当前需要修改的数字修改为它左边的数字；

## 1.2 代码

```
public boolean checkPossibility(int[] nums) {
        if(nums==null||nums.length<=0){
            return true;
        }
        int count = 0;
        //防止资源浪费
        for(int i =1;i<nums.length&& count < 2;i++){
        	if (nums[i-1] <= nums[i]) {
    			continue;
    		}
        	count++;
        	//如果在中间位置，则将该位置数和前一个数同步
        	if(i-2>=0&&nums[i-2]>nums[i]) {
        		nums[i] = nums[i-1];//情况3
        	}else { 
        		//若为最左边的数，则将其设置为旁边的数
				nums[i-1] = nums[i];//情况1
			}
        	
        }
        return count<=1;
    }
```

## 1.3 复杂度分析

* 时间复杂度：`O(n)`,仅仅轮询一次数组
* 空间复杂度：`O(1)`,为引入额外存储空间

