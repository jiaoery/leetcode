# 解题思路

## 1.1动态规划算法

这里要降低时间空间复杂度，需要使用动态规划复用空间。那么从上一题的思路。我们可以思考，目标行的结果与之前行的区别，在于:

- 当`i==0`;或者`i==j`；`a[i][j]=1`
- 其他情况下`a[i][j]=a[i-1][j-1]+a[i-1][j]`

那是可以使用动态规划算法来实现的。具体的思路如下：

```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
其中行列均从0开始；第n行具备n+1个元素;从第2行（0开始），从右往左的规律能被简化为
a[j] = a[j]+a[j-1].
不明白？那就示例示范一下：
假设n = 4
首先，填充所有元素：
1 1 1 1 1
然后由于n>2;所以先求解第二行的数据样式，此时行数 i=2
1 2（原数组a[1]=a[1]+a[0]）1 1 1
然后求解第三行数据，此时行数 i =3
第一步：
1 2 3（a[2]=a[2]+a[1]）1 1
第二步：
1 3 3 1 1  
为何从右往左计算，就是为了不覆盖原有的a[i-1]的数据
然后求解第四行数据，此时行数 i=4
第一步：
1 3 3 4 1  （a[3]=a[3]+a[2]）
第二步：
1 3 6 4 1   (a[2]=a[2]+a[1])
第三步：
1 4 6 4 1   (a[1]=a[1]+a[0])

最终结果符合杨辉三角。
```

## 1.2 代码

```
public static List<Integer> getRow(int rowIndex) {
		Integer[] dp = new Integer[rowIndex+1];
		//全部填充为
		Arrays.fill(dp, 1);
		//从第2行开始规划
		for (int i = 2; i < dp.length; i++) {
			for(int j = i-1;j>0;j--) {
				dp[j] = dp[j] + dp[j-1];
			}
		}
		return Arrays.asList(dp);
    }
```

## 1.3 复杂度分析

* 时间复杂度：`O(n^2)`,两层嵌套
* 空间复杂度：`O(n)`只是用一个长度为`n+1`的数组