# 解题思路

## 前言

第一次见这个题目，还是蒙蔽中的状态。脑子里闪过几个想法，1.想过用String split将字符串分成1和0单独的两个字串，2.想使用双指针算法来求解。但是一想都复杂了。然后仔细看了下题目（以前就是读题不谨慎出丑），发现了一个规律：

> 比如题目中“00110011”可以转换为一个int数组，分别表示1或者0连续出现的次数，比如这里就可以转换成int[] counts = {2,2,2,2};然后肯定后一个前一个，一定取最小值，这不就可以找出符合的字串有2+2+2=6个。“10101”，转换成int[] counts = {1,1,1,1,1}.也就是1+1+1+1=4
>
> 可能这个不具体，我们可以再找一个不是很规律的
>
> "001101001011" ，它可以被转换成int[] counts = {2,2,1,1,2,1,1,2},也就是2+1+1+1+1+1+1=8.分别是“0011”，“01”，“10”，“01”，“10”，“01”，“10”，“01”。

规律找到了，那就好办了

## 1.1 计数

按照前面的规律，可以把原有的字符串转换成一个int数组的方式来解决，但是，这样会引入一个数组，导致空间复杂度增加。那么进一步寻找规律，发现最终求解结果是前后两个int参数求解min最小值，是否可以使用一个参数来缓存呢。那么解决的流程如下：

* 1.求解第一个参数1或0的连续数count，存入缓存参数last；
* 2.求解第二个参数的连续数count，对比min（count,last）并计入总数ans,将count存入缓存参数last。
* 持续以上步骤直计数完所有参数，返回ans

## 1.2 代码

```
 public int countBinarySubstrings(String s) {
        //上次记录last,当前总和ans
		int index=0,n=s.length(),last = 0, ans = 0;
		while(index<n) {
			//记录此次0或1出现的次数
			int count = 0;
			//每次取一个char
			char c = s.charAt(index);
			while(index<n&&s.charAt(index) == c) {
				index++;
				count++;
			}
			//取前后值最小值
			ans += Math.min(last,count);
			//将当前统计次数记录
			last =count;
		}
		return ans;
    }
```

## 1.3 复杂度分析

* 时间复杂度：`O(n)`。
* 空间复杂度：`O(1)`。